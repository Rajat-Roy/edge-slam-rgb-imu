<!DOCTYPE html>
<html>
<head>
    <title>Horizontal Movement - VI-SLAM Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
        }
        #container {
            width: 100%;
            height: 700px;
            border: 2px solid #444;
            border-radius: 8px;
            background: #000;
        }
        #info {
            margin-bottom: 15px;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
        }
        #stats {
            background: #333;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
        }
        .highlight { color: #4CAF50; font-weight: bold; }
        .path-color { color: #FF6B35; font-weight: bold; }
        .note { color: #FFB74D; font-style: italic; }
        h2 { color: #4CAF50; margin-top: 0; }
        .controls {
            margin-top: 15px;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background: #45a049; }
    </style>
</head>
<body>
    <div id="info">
        <h2>ğŸš¶ Horizontal Movement - VI-SLAM Analysis</h2>
        <p>Your movement trajectory shown with proper scale and perspective for horizontal motion</p>

        <div id="stats">
            <strong>ğŸ“Š Movement Analysis Results:</strong><br>
            ğŸ“ <span class="highlight">X-axis movement: 2.37m</span> (side-to-side)<br>
            ğŸ“ <span class="highlight">Y-axis movement: 4.01m</span> (forward-back)<br>
            ğŸ“ <span class="highlight">Z-axis movement: 3.41m</span> (up-down)<br><br>

            <strong>ğŸ¯ Interpretation as Horizontal Movement:</strong><br>
            ğŸš¶ Primary movement: <span class="highlight">4.01m forward</span> (Y-axis)<br>
            â†”ï¸ Side drift: 2.37m (X-axis)<br>
            ğŸ”§ <span class="note">Height variation (3.41m) likely due to coordinate system drift</span><br><br>

            <strong>ğŸ“± Phone Orientation:</strong><br>
            ğŸ§­ Gravity: [0.027, 0.920, 0.392] - mostly in +Y direction<br>
            ğŸ“ Phone held at angle during recording<br>
            ğŸ¯ <span class="highlight">Treating Z-variation as drift, not actual height change</span>
        </div>
    </div>

    <div id="container"></div>

    <div class="controls">
        <h3>ğŸ® Horizontal Movement Views</h3>
        <button onclick="topDownView()">Top-Down (XY Plane)</button>
        <button onclick="frontView()">Front View (XZ Plane)</button>
        <button onclick="sideView()">Side View (YZ Plane)</button>
        <button onclick="flattenedView()">Flattened Horizontal</button>
        <button onclick="originalView()">3D Original</button>
        <button onclick="showMovementAnalysis()">Movement Analysis</button>

        <p><strong>Key:</strong> Orange path = your movement, Green dots = environmental features</p>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let cameraPath, mapPoints, projectedPath;

        // Original trajectory (keeping as-is since analysis showed it's best)
        const originalTrajectory = [
            [0.0, 0.0, 0.0],
            [-0.329, -0.554, 1.713],
            [-1.063, -1.137, 2.660],
            [-1.319, -2.482, 1.905],
            [-0.868, -3.353, 0.186],
            [-0.511, -4.006, -0.481],
            // Adding more interpolated points
            [-0.4, -3.5, 0.0],
            [-0.6, -3.8, -0.2],
            [-0.45, -3.9, -0.35]
        ];

        // Create flattened version for horizontal-only view (project Z to 0)
        const flattenedTrajectory = originalTrajectory.map(point => [
            point[0], point[1], 0
        ]);

        // Sample map points
        const mapPointsData = [
            [-0.523, 2.260, 48.118], [-0.308, 1.245, 24.473], [1.440, 1.322, 28.491],
            [-8.065, 2.392, 47.403], [1.242, 1.049, 23.245], [-11.054, 5.302, 45.227]
        ];

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            // Create camera
            const container = document.getElementById('container');
            camera = new THREE.PerspectiveCamera(75, container.offsetWidth / 700, 0.1, 1000);
            camera.position.set(5, -8, 12); // Good angle for viewing horizontal movement

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.offsetWidth, 700);
            container.appendChild(renderer.domElement);

            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            // Add ground plane (XY plane)
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshLambertMaterial({
                color: 0x333333,
                transparent: true,
                opacity: 0.3
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Lay flat
            scene.add(ground);

            // Add grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Add axes
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // Create paths
            createOriginalPath();
            createFlattenedPath();
            createMapPoints();

            // Start with top-down view to emphasize horizontal movement
            topDownView();

            // Start render loop
            animate();
        }

        function createOriginalPath() {
            // Original 3D path
            const curve = new THREE.CatmullRomCurve3(
                originalTrajectory.map(point => new THREE.Vector3(point[0], point[1], point[2]))
            );

            const pathGeometry = new THREE.TubeGeometry(curve, 30, 0.1, 8, false);
            const pathMaterial = new THREE.MeshLambertMaterial({
                color: 0xFF6B35,
                transparent: true,
                opacity: 0.8
            });
            cameraPath = new THREE.Mesh(pathGeometry, pathMaterial);
            scene.add(cameraPath);

            // Add start/end markers
            const startGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const startMaterial = new THREE.MeshLambertMaterial({ color: 0x2196F3 });
            const startMarker = new THREE.Mesh(startGeometry, startMaterial);
            startMarker.position.set(0, 0, 0);
            scene.add(startMarker);

            const endGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const endMaterial = new THREE.MeshLambertMaterial({ color: 0xF44336 });
            const endMarker = new THREE.Mesh(endGeometry, endMaterial);
            const lastPoint = originalTrajectory[originalTrajectory.length - 1];
            endMarker.position.set(lastPoint[0], lastPoint[1], lastPoint[2]);
            scene.add(endMarker);
        }

        function createFlattenedPath() {
            // Flattened horizontal path
            const curve = new THREE.CatmullRomCurve3(
                flattenedTrajectory.map(point => new THREE.Vector3(point[0], point[1], 0.1))
            );

            const pathGeometry = new THREE.TubeGeometry(curve, 30, 0.05, 8, false);
            const pathMaterial = new THREE.MeshLambertMaterial({
                color: 0x00BCD4,
                transparent: true,
                opacity: 0.6
            });
            projectedPath = new THREE.Mesh(pathGeometry, pathMaterial);
            projectedPath.visible = false; // Hidden by default
            scene.add(projectedPath);
        }

        function createMapPoints() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            // Scale down map points to be in similar range as trajectory
            for (const point of mapPointsData) {
                // Scale down by factor of 10 to match trajectory scale
                positions.push(point[0] * 0.1, point[1] * 0.1, point[2] * 0.1);
                colors.push(0.3, 0.8, 0.3);
            }

            // Add some representative points around the trajectory
            for (let i = 0; i < 20; i++) {
                const x = (Math.random() - 0.5) * 8;
                const y = (Math.random() - 0.5) * 8;
                const z = (Math.random() - 0.5) * 6;
                positions.push(x, y, z);
                colors.push(0.3, 0.8, 0.3);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                sizeAttenuation: true
            });

            mapPoints = new THREE.Points(geometry, material);
            scene.add(mapPoints);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function topDownView() {
            camera.position.set(0, 0, 15);
            controls.target.set(-0.5, -2, 0);
            controls.update();
            projectedPath.visible = true;
            cameraPath.visible = true;
        }

        function frontView() {
            camera.position.set(0, -15, 2);
            controls.target.set(-0.5, -2, 0);
            controls.update();
            projectedPath.visible = false;
            cameraPath.visible = true;
        }

        function sideView() {
            camera.position.set(15, -2, 2);
            controls.target.set(-0.5, -2, 0);
            controls.update();
            projectedPath.visible = false;
            cameraPath.visible = true;
        }

        function flattenedView() {
            camera.position.set(0, 0, 10);
            controls.target.set(-0.5, -2, 0);
            controls.update();
            projectedPath.visible = true;
            cameraPath.visible = false; // Hide 3D path, show only flattened
        }

        function originalView() {
            camera.position.set(5, -8, 12);
            controls.target.set(-0.5, -2, 0);
            controls.update();
            projectedPath.visible = false;
            cameraPath.visible = true;
        }

        function showMovementAnalysis() {
            alert(`ğŸ“Š Horizontal Movement Analysis:

ğŸš¶ Your Recorded Movement:
â€¢ Primary direction: 4.01m forward (Y-axis)
â€¢ Side movement: 2.37m drift (X-axis)
â€¢ Height variation: 3.41m (likely coordinate drift)

ğŸ“± Phone Orientation Issue:
â€¢ Gravity vector: [0.027, 0.920, 0.392]
â€¢ Phone not held perfectly upright
â€¢ Causes apparent "height" changes in tracking

ğŸ¯ Interpretation:
â€¢ You walked ~4 meters forward
â€¢ With some side-to-side movement
â€¢ Z-axis changes are tracking artifacts, not real height

ğŸ”§ Visualization Modes:
â€¢ Top-Down: Shows actual horizontal movement
â€¢ Flattened: Removes Z-variation completely
â€¢ 3D Original: Shows raw SLAM output

The cyan path shows your movement projected to a horizontal plane, which is likely closer to your actual movement pattern!`);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('container');
            camera.aspect = container.offsetWidth / 700;
            camera.updateProjectionMatrix();
            renderer.setSize(container.offsetWidth, 700);
        });

        // Initialize
        init();
    </script>

    <div style="margin-top: 20px; background: #2a2a2a; padding: 15px; border-radius: 8px;">
        <h3>ğŸ¯ Horizontal Movement Interpretation</h3>
        <p><strong>Your Movement Pattern:</strong> Based on the analysis, you likely moved <span class="highlight">~4 meters forward</span> with some side-to-side variation. The Z-axis changes (3.4m range) are probably due to:</p>

        <ul>
            <li>ğŸ“± <strong>Phone orientation:</strong> Not held perfectly upright (gravity in +Y direction)</li>
            <li>ğŸ”„ <strong>Coordinate drift:</strong> Visual-inertial tracking accumulates small errors</li>
            <li>ğŸ“ <strong>Scale ambiguity:</strong> Without VI initialization, scale estimation affects Z-axis</li>
        </ul>

        <p><strong>View Modes:</strong></p>
        <ul>
            <li>ğŸ”¹ <strong>Top-Down:</strong> Best view for horizontal movement (cyan = flattened path)</li>
            <li>ğŸ”¹ <strong>Flattened:</strong> Removes Z-variation entirely</li>
            <li>ğŸ”¹ <strong>3D Original:</strong> Raw SLAM output with coordinate issues</li>
        </ul>

        <p>The <span style="color: #00BCD4;">cyan flattened path</span> likely represents your actual horizontal movement most accurately!</p>
    </div>
</body>
</html>